<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Neon Mandelbrot (Simple, Loads on Page Open)</title>
  <style>
    :root { color-scheme: dark; }
    html, body {
      margin: 0;
      height: 100%;
      background: #0b0b0f;
      color: #e8e8ff;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    }
    header {
      text-align: center;
      padding: 12px 8px;
      font-weight: 700;
      letter-spacing: .06em;
    }
    #wrap {
      display: grid;
      place-items: center;
      height: calc(100% - 56px);
    }
    canvas {
      background: black;
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(0,0,0,.6), 0 0 40px rgba(128,0,255,.25) inset;
      max-width: 95vw;
      max-height: calc(95vh - 56px);
    }
    .hint {
      position: fixed;
      left: 12px; bottom: 10px;
      opacity: .7; font-size: 12px;
    }
  </style>
</head>
<body>
  <header>NEON MANDELBROT — static render (no animation)</header>
  <div id="wrap">
    <canvas id="fractalCanvas" width="1280" height="800"></canvas>
  </div>
  <div class="hint">If you see a blank page, open DevTools → Console to check for errors.</div>

  <script>
    'use strict';

    // ====== Color palettes that return integer [r,g,b] ======
    const palettes = {
      magma(t) {
        const r = Math.min(255, 250 + Math.sin(t * 10) * 5);
        const g = Math.min(255, 100 + Math.sin(t * 15) * 30);
        const b = Math.min(255, 120 + Math.sin(t * 20) * 40);
        return [r|0, g|0, b|0];
      },
      plasma(t) {
        const r = Math.min(255, 200 + Math.sin(t * 15) * 55);
        const g = Math.min(255,  50 + Math.sin(t * 10) * 50);
        const b = Math.min(255, 150 + Math.sin(t * 20) * 105);
        return [r|0, g|0, b|0];
      },
      inferno(t) {
        const r = Math.min(255, 220 + Math.sin(t * 12) * 35);
        const g = Math.min(255, 100 + Math.sin(t * 18) * 50);
        const b = Math.min(255,  30 + Math.sin(t * 25) * 30);
        return [r|0, g|0, b|0];
      },
      viridis(t) {
        const r = Math.min(255,  50 + Math.sin(t * 15) * 50);
        const g = Math.min(255, 150 + Math.sin(t * 20) * 50);
        const b = Math.min(255, 180 + Math.sin(t * 25) * 50);
        return [r|0, g|0, b|0];
      },
      rainbow(t) {
        const r = Math.sin(t * 6.28318530718) * 127 + 128;
        const g = Math.sin(t * 6.28318530718 + 2) * 127 + 128;
        const b = Math.sin(t * 6.28318530718 + 4) * 127 + 128;
        return [r|0, g|0, b|0];
      },
      // Fixed syntax: all parentheses present
      electric(t) {
        const r = Math.abs(Math.sin(t * 6.0)) * 255;
        const g = Math.abs(Math.sin(t * 6.0 + Math.PI/3)) * 255;
        const b = Math.abs(Math.sin(t * 6.0 + 2*Math.PI/3)) * 255;
        return [r|0, g|0, b|0];
      }
    };

    // ====== Canvas sizing (crisp on HiDPI) ======
    const canvas = document.getElementById('fractalCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    function fitCanvasToScreen() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const maxCSSWidth = Math.min(1280, Math.floor(window.innerWidth * 0.95));
      const maxCSSHeight = Math.min(800, Math.floor((window.innerHeight - 56) * 0.95));

      // Keep ~16:10 aspect like the original
      const targetAspect = 16 / 10;
      let cssW = maxCSSWidth, cssH = Math.floor(cssW / targetAspect);
      if (cssH > maxCSSHeight) {
        cssH = maxCSSHeight;
        cssW = Math.floor(cssH * targetAspect);
      }

      canvas.style.width = cssW + 'px';
      canvas.style.height = cssH + 'px';
      canvas.width = Math.floor(cssW * dpr);
      canvas.height = Math.floor(cssH * dpr);
    }

    // ====== Mandelbrot core ======
    function drawMandelbrot({
      palette = 'electric',
      maxIter = 250,
      centerX = -0.75,
      centerY = 0.0,
      viewWidth = 3.5 // horizontal width in complex plane
    } = {}) {
      const width = canvas.width;
      const height = canvas.height;

      // Maintain aspect ratio vertically
      const aspect = height / width;
      const halfW = viewWidth / 2;
      const halfH = halfW * aspect;
      const xmin = centerX - halfW;
      const xmax = centerX + halfW;
      const ymin = centerY - halfH;
      const ymax = centerY + halfH;

      const img = ctx.createImageData(width, height);
      const data = img.data;
      const getColor = palettes[palette] || palettes.electric;

      for (let py = 0; py < height; py++) {
        const cy = ymin + (ymax - ymin) * (py / (height - 1));
        for (let px = 0; px < width; px++) {
          const cx = xmin + (xmax - xmin) * (px / (width - 1));

          // Iterate z <- z^2 + c
          let x = 0, y = 0, iter = 0;
          let x2 = 0, y2 = 0;
          while ((x2 + y2) <= 4 && iter < maxIter) {
            y = 2 * x * y + cy;
            x = x2 - y2 + cx;
            x2 = x * x;
            y2 = y * y;
            iter++;
          }

          const idx = (py * width + px) * 4;
          if (iter === maxIter) {
            // Inside set: black
            data[idx] = data[idx+1] = data[idx+2] = 0;
          } else {
            // Smooth coloring (prettier gradients)
            const log_zn = Math.log(x2 + y2) / 2;
            const nu = Math.log(log_zn / Math.log(2)) / Math.log(2);
            let t = (iter + 1 - nu) / maxIter;
            if (!isFinite(t) || t < 0) t = 0;
            if (t > 1) t = 1;

            const [r, g, b] = getColor(t);
            data[idx]   = r;
            data[idx+1] = g;
            data[idx+2] = b;
          }
          data[idx+3] = 255; // alpha
        }
      }

      ctx.putImageData(img, 0, 0);
    }

    // ====== Boot ======
    function render() {
      fitCanvasToScreen();
      drawMandelbrot({
        palette: 'electric', // try: 'magma','plasma','inferno','viridis','rainbow','electric'
        maxIter: 300
      });
    }

    window.addEventListener('resize', () => {
      // simple debounce
      clearTimeout(window.__resizeTimer);
      window.__resizeTimer = setTimeout(render, 120);
    });

    // Draw on first load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', render);
    } else {
      render();
    }
  </script>
</body>
</html>
