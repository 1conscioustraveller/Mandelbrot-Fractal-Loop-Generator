<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Mandelbrot Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes pulse-glow {
            0%, 100% { filter: drop-shadow(0 0 5px currentColor); }
            50% { filter: drop-shadow(0 0 20px currentColor); }
        }
        @keyframes vibrate {
            0% { color: #ff00ff; }
            25% { color: #00ffff; }
            50% { color: #ffff00; }
            75% { color: #ff00ff; }
            100% { color: #00ffff; }
        }
        .neon-text {
            animation: vibrate 5s infinite, pulse-glow 3s infinite;
        }
        .neon-border {
            border: 2px solid;
            animation: pulse-glow 4s infinite alternate;
        }
        canvas {
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
    </style>
</head>
<body class="bg-black text-white min-h-screen flex flex-col">
    <!-- [Previous HTML structure remains exactly the same] -->
    
    <script>
        // [Previous loadSettings(), saveSettings(), updateSliderValues() remain the same]

        // Initialize canvas and context
        const canvas = document.getElementById('fractalCanvas');
        const ctx = canvas.getContext('2d');
        if (!ctx) {
            console.error("Failed to get canvas context!");
            document.getElementById('status').textContent = "Error: Canvas not supported";
        }

        // Set canvas size with debug checks
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = Math.max(100, container.clientWidth - 40);
            canvas.height = Math.max(100, Math.min(canvas.width * 0.75, window.innerHeight - 300));
            console.log("Canvas resized to:", canvas.width, "x", canvas.height);
        }

        // Revised Color Palettes with Safeguards
        const colorPalettes = {
            magma: (t) => {
                const r = Math.min(255, 250 + Math.sin(t * 10) * 5);
                const g = Math.min(255, 100 + Math.sin(t * 15) * 30);
                const b = Math.min(255, 120 + Math.sin(t * 20) * 40);
                return `rgb(${r},${g},${b})`;
            },
            // [Other palettes remain similar...]
            electric: (t) => {
                const r = Math.floor(Math.abs(Math.sin(t * 0.05)) * 255);
                const g = Math.floor(Math.abs(Math.sin(t * 0.05 + Math.PI/3)) * 255);
                const b = Math.floor(Math.abs(Math.sin(t * 0.05 + 2*Math.PI/3)) * 255);
                return `rgb(${r},${g},${b})`;
            }
        };

        // Robust RGB Parser
        function parseRGB(color) {
            if (!color.startsWith('rgb(')) return [255, 0, 255]; // Fallback: magenta
            try {
                const parts = color.slice(4, -1).split(',').map(s => parseInt(s.trim()));
                return parts.length === 3 ? parts : [255, 0, 255];
            } catch {
                return [255, 0, 255];
            }
        }

        // Revised Mandelbrot Drawing
        function drawMandelbrot(xmin = -2.5, xmax = 1, ymin = -1.1, ymax = 1.1, maxIter = 100) {
            if (!ctx) return;
            
            const width = canvas.width;
            const height = canvas.height;
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;
            const getColor = colorPalettes[document.getElementById('colorScheme').value] || colorPalettes.magma;
            
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    const cx = xmin + (xmax - xmin) * x / width;
                    const cy = ymin + (ymax - ymin) * y / height;
                    
                    const iter = mandelbrot({ x: cx, y: cy }, maxIter);
                    const idx = (y * width + x) * 4;
                    
                    if (iter === maxIter) {
                        data.set([0, 0, 0, 255], idx); // Black for set
                    } else {
                        const [r, g, b] = parseRGB(getColor(iter));
                        data.set([r, g, b, 255], idx);
                    }
                }
            }
            ctx.putImageData(imageData, 0, 0);
        }

        // [Rest of your original JavaScript (mandelbrot(), previewAnimation(), etc.) 
        // remains the same, but uses the new parseRGB() function]

        // Enhanced initialization
        document.addEventListener('DOMContentLoaded', () => {
            resizeCanvas();
            loadSettings();
            
            // Double-check canvas is ready
            setTimeout(() => {
                console.log("Initial draw starting...");
                drawMandelbrot();
            }, 100);
            
            // [Rest of your original event listeners]
        });
    </script>
</body>
</html>
